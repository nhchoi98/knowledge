# 렌더링 최적화

# Reflow

- 요소의 크기(width, height), 위치, 구조에 변화가 생기면 전체 문서 흐름(Layout Tree)을 다시 계산해야 함.
- DOM 트리 → Render Tree → Layout 계산 과정을 다시 수행 → 이후 Repaint까지 이어짐.
- 특히 한 요소의 Reflow가 **부모·자식·형제 요소**까지 전파될 수 있어 비용이 매우 커짐.
- 예: `display: none`, `position 변경`, `width/height 변경`.

# Repaint

- 요소의 **시각적 속성**만 변경될 때 발생 (예: color, background-color, opacity).
- 레이아웃 트리(Layout Tree)나 위치 계산은 필요 없고, 단순히 픽셀을 다시 칠하면 끝.
- 따라서 상대적으로 성능 부담이 적음.

## Repaint와 Reflow(Layout)의 차이점은 무엇인가요?

- **Repaint**: 요소의 스타일(색상, 배경, visibility 등)만 바뀌어 다시 그려야 하는 경우.
- **Reflow(Layout)**: 요소의 크기나 위치, 레이아웃 자체가 변해서 다시 계산해야 하는 경우.
- Reflow는 레이아웃 트리 재계산 → Render Tree 업데이트 → Paint 과정까지 이어짐.
- 따라서 Reflow는 더 무겁고, 빈번하면 성능 저하 발생.

## display: none과 visibility: hidden은 Reflow/Repaint 관점에서 어떤 차이가 있나요?

- display: none → 레이아웃에서 제외 → Reflow 발생
- visibility: hidden → 레이아웃 유지, 단순 스타일 변경 → Repaint만 발생

## 브라우저 렌더링 과정에서 언제 Repaint가 발생하나요?

**Repaint**는 **요소의 위치나 레이아웃에는 변화가 없고, 시각적인 스타일만 변경되었을 때** 발생합니다.

즉, 레이아웃 재계산(Layout, Reflow)은 필요 없지만, **픽셀을 다시 칠해야 하는 경우**에 브라우저가 Repaint를 수행합니다.

## Reflow를 줄이기 위해 Virtual DOM이나 Vue같은 라이브러리에서는 어떤 방식으로 최적화할까요?

- **목표는 DOM 터치 최소화**: 레이아웃(Layout) 재계산을 유발하는 DOM 변경을 “최소 개수·최소 영역·최소 횟수”로 묶어 처리.
- **측정(읽기)과 변경(쓰기)의 분리**: 읽기→쓰기 순서로 배치해 **layout thrashing**(읽기·쓰기가 교차하며 강제 Reflow 유발)을 피함.
- **가능하면 페인트만 유발**: transform/opacity 같은 **compositor-friendly** 속성으로 애니메이션.

## FOUC란?

FOUC는 Flash of Unstyled Content의 약자로, **웹 페이지에 스타일이 적용된 CSS 파일이 로드되기 전에, 스타일이 적용되지 않은 상태의 웹 페이지 내용이 잠시 보이는 현상**을 의미합니다.

### 해결방법 1. **CSS를 HTML 문서의 <head> 태그에 배치:**

브라우저는 HTML 문서를 순차적으로 해석하므로, 스타일을 가능한 한 빨리 로드하려면 <head> 태그 내에 <link> 태그를 사용하여 CSS 파일을 연결하는 것이 좋습니다. 이렇게 하면 브라우저가 렌더링을 시작하기 전에 스타일을 먼저 로드하고 적용할 수 있습니다.

### 해결방법 2. **인라인 CSS 사용**

인라인 스타일은 별도의 HTTP 요청 없이 페이지와 함께 로드되기 때문에 렌더링 속도가 빨라질 수 있습니다. 하지만 이 방법은 파일 크기가 커질 수 있으므로, 필수적인 스타일 정보만 인라인으로 삽입하는 것이 좋습니다. 이를 부분적으로 적용하기 위해크리티컬 CSS라는 기법을 사용할 수 있습니다.

> 
> 
> 
> 크리티컬 CSS란 웹 페이지의 초기 렌더링에 영향을 미치는 중요한 스타일을 인라인으로 삽입하는 방법입니다.
> 

## FOUT란?

flash of invisible text

웹 폰트를 사용하는 경우, 브라우저가 웹 폰트 파일을 다운로드하고 파싱하는데 시간이 걸릴 수 있습니다. 웹 폰트가 아직 로드되지 않았을 때, 브라우저는 시스템 기본 폰트를 사용하여 텍스트를 먼저 렌더링합니다. 웹 폰트가 로드되면, 브라우저는 렌더 트리를 업데이트하여 웹 폰트를 적용한 텍스트를 표시하게 됩니다. 이 과정에서 사용자는 잠시 웹 폰트가 적용되지 않은 텍스트를 볼 수 있게 됩니다.

### 해결방법

웹 폰트 로드 최적화:웹 폰트를 불러오는 방식을 최적화하면 FOUT 현상을 줄일 수 있습니다. 예를 들어, <link> 태그의 preload 속성을 사용하여 웹 폰트를 미리 로드할 수 있습니다. 또는 CSS font-display 속성을 사용하여 웹 폰트의 로드 및 렌더링 동작을 조절할 수 있습니다.

## FOUC, FOUT 발생하는 이유

브라우저는 HTML, CSS, JavaScript 파일을 로드하여 웹 페이지를 렌더링합니다. HTML은 페이지의 구조를 정의하고, CSS는 스타일을 적용하며, JavaScript는 동작을 추가합니다. 이 과정에서 브라우저는 다음 단계를 거칩니다.

- HTML 파싱: 브라우저는 HTML 파일을 파싱하여 DOM(Document Object Model) 트리를 생성합니다.
- CSS 파싱: 브라우저는 CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
- 렌더 트리 생성: DOM 트리와 CSSOM 트리를 합쳐서 렌더 트리를 생성합니다. 이 트리는 페이지의 시각적 요소를 나타냅니다.레이아웃: 렌더 트리의 요소들에 대한 위치와 크기를 계산합니다.
- 페인팅: 최종적으로 스타일과 레이아웃 정보를 바탕으로 화면에 요소를 그립니다.

> FOUC와 FOUT 현상은주로 렌더 트리 생성 및 레이아웃 단계에서 발생합니다. 스타일 정보가 늦게 도착하거나, 웹 폰트가 로드되는 동안 브라우저가 기본 폰트로 렌더링하기 때문입니다.
> 
1. **HTML 파싱:** 브라우저는 HTML 파일을 파싱하여 DOM(Document Object Model) 트리를 생성합니다.
2. **CSS 파싱:** 브라우저는 CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
3. **렌더 트리 생성:** DOM 트리와 CSSOM 트리를 합쳐서 렌더 트리를 생성합니다. 이 트리는 페이지의 시각적 요소를 나타냅니다.
4. **레이아웃:** 렌더 트리의 요소들에 대한 위치와 크기를 계산합니다.
5. **페인팅:** 최종적으로 스타일과 레이아웃 정보를 바탕으로 화면에 요소를 그립니다.

## HTML 문서에서 `<style>` 태그를 어디에 두느냐에 따라 **브라우저 렌더링 과정**과 **성능**에 영향을 줄 수 있습니다.

## ✅ 1. `<head>` 안에 위치할 때 (권장)

- 일반적으로 **권장되는 위치**
- 브라우저는 HTML을 위에서 아래로 해석하면서 DOM과 CSSOM을 함께 구축합니다.
- `<head>` 안에 `<style>`이 있으면, **렌더링 차단(blocking)** 없이 CSSOM을 먼저 완성할 수 있음 → 화면이 빠르게 **정상 스타일로 그려짐**

## ✅ 2. `<body>` 안에 위치할 때

- HTML이 이미 파싱되고 화면에 그려진 뒤에 `<style>`이 적용됨
- 따라서 **초기에 깜빡임(FOUC)**이 발생할 수 있음
- 동적으로 특정 부분에만 스타일을 주고 싶을 때는 사용할 수 있음 (예: JS가 동적으로 `<style>` 삽입)

## ✅ 3. `<style>` 태그의 **순서**

- 같은 선택자가 여러 번 정의되면, **나중에 선언된 것**이 우선순위를 가짐 (CSS Cascading 규칙)

## ✅ 4. `<style>` vs `<link rel="stylesheet">`

- `<style>`: 인라인 CSS 정의 (HTML 안에 직접 작성)
- `<link>`: 외부 CSS 파일 로드 (재사용, 캐싱 가능)
- **성능상**: 외부 CSS를 `<head>` 상단에 넣는 것이 가장 안정적

## 🚀 정리

- `<head>` 안에 두는 게 표준적이고, FOUC를 방지할 수 있어 **가장 권장됨**
- `<body>` 안에 있으면 화면이 먼저 뜬 후 스타일이 적용되어 **깜빡임/성능 저하** 발생
- 순서가 다르면, **나중 선언된 스타일이 우선 적용됨**

👉 면접 답변 예시:

> “<style>은 보통 <head>에 두는 게 권장됩니다. 그래야 브라우저가 DOM과 CSSOM을 동시에 만들어서 빠르게 정상 렌더링할 수 있고, FOUC 현상을 줄일 수 있습니다. <body>에 두면 스타일이 늦게 적용되어 Reflow/Repaint가 발생할 수 있고 성능에 불리합니다
> 

# Layout Thrashing

**Layout Thrashing**은 브라우저 렌더링 과정에서 **레이아웃 계산(Layout/Reflow)**이 반복해서 강제로 발생하면서 성능이 크게 떨어지는 현상을 말합니다.

브라우저는 DOM과 CSSOM을 합쳐서 **렌더 트리(Render Tree)**를 만들고,

이걸 기반으로 **Layout → Paint → Composite** 단계를 거쳐 화면을 그려요.

- **Layout/Reflow**: 각 요소의 크기와 위치 계산
- **Paint**: 픽셀로 변환
- **Composite**: 레이어 합성

👉 `offsetWidth`, `clientHeight` 같은 속성을 읽으면 브라우저는 **최신 레이아웃 값을 보장**하기 위해 강제로 Layout을 다시 계산합니다.

👉 그 직후에 스타일 변경(write)을 하면 다시 Layout이 깨지고 재계산.

## 2. Layout Thrashing이란?

- **읽기(Read)** → **쓰기(Write)** → **읽기(Read)** → **쓰기(Write)** 패턴이 반복되면서,
- 브라우저가 **레이아웃을 매번 다시 계산(Reflow)**해야 하는 상황.

즉, “읽기-쓰기-읽기-쓰기”가 뒤섞여서 브라우저 성능을 박살내는 현상이에요.

### 해결방법

1. **가상 DOM / 라이브러리 활용**
    - React/Vue 같은 라이브러리는 내부적으로 batch update를 해서 Layout Thrashing을 줄여줌.

**requestAnimationFrame 활용**

- 브라우저 렌더링 사이클에 맞춰 batch 처리

# Vue의 `computed` vs `watch` vs `methods`의 차이를 설명하고, 어떤 상황에서 성능 최적화에 기여하나요?

# Lazy loading

## CSS 애니메이션과 JS 애니메이션 중 성능 측면에서 어떤 차이가 있나요?

| 구분 | CSS 애니메이션 | JS 애니메이션 |
| --- | --- | --- |
| 실행 위치 | 브라우저 컴포지터 스레드 (JS와 분리) | JS 메인 스레드 |
| 성능 | GPU 가속(transform/opacity)시 매우 부드러움 | JS 부하에 따라 프레임 드랍 발생 가능 |
| 제어 | 단순, 제한적 | 동적 제어 가능 (중단, 조건 분기 등) |
| 구현 난이도 | 간단 (transition, keyframes) | 복잡 (rAF, 수학 계산 필요) |
| 활용 추천 | 단순 UI 전환, fade-in/out, 슬라이드 | 물리 기반, 인터랙티브, 커스텀 애니메이션 |