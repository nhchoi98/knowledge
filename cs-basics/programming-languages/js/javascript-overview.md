---
title: Javascript
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# Javascript

## ECMAScript

- **ECMAScript**: 프로그래밍 언어 사양(표준)
- **JavaScript**: ECMAScript를 기반으로 브라우저 환경 기능을 추가한 구현체
- 그래서 "ES6", "ES2015" 같은 용어는 ECMAScript의 특정 버전을 의미합니다.

# 변수

## 특징 1

할당에 의해 타입이 결정된다.  또한, 재할당에 의해 타입이 동적으로 변할 수 있는데**, 이는 동적 타입언어 이기 때문에 가지게 되는 특징이다.** 

## 특징 2

변경 불가능하다는 것은, 변수가 아니라 값에 대한 진술(메모리 주소)이다.

## 유의점 1

스코프는 가능한 한 작게 선언하는 것이 좋다. 

## Primitive Type

원시 값은 변경 불가능한 값 (Immutable value)이다. 

### Symbol

다른 값과 중복되지 않는 유일무이한 값이다. Symbol은 다른 원시 값과 다르게 함수를 호출해 생성된다. 

(다른 애들은 리터럴을 통해 생성됨)

### Number

정수와 실수 구분 없이 하나의 숫자 타입만이 존재한다. 

Double precision floating point로써 값을 저장한다. (64비트)

## Object Type

객체는 변경 가능한 값 (Mutable value)이다. 

## 불변성

- 재할당 시, 새로우 메모리 공간을 확보하고 재할당한 값을 계산한 후, 변수가 참조하던 메모리 공간의 주소를 변경하는 것을 불변성이라고 한다.
- Javascript에서 Primitive type은 이러한 성질을 갖는다.

## 

# 연산

## 동등 연산 (Loose equality) , ===

좌항과 우항의 피연산자를 비교할 때, 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 

같은 값일 수 있다면, True를 반환한다.  

## 일치 연산 (Strict equality), ==

좌항과 우항의 피연산자를 비교할 때, 타입도 같고 값도 같을 때 True를 반환한다. 

단, NaN은 자기 자신을 비교해도 False를 가진다. 

## Falsy

거짓으로 평가되는 값.

여기에는 0, ‘’, NaN, undefined, null, false 이 있다. 

## Truthy

참으로 평가되는 값. Falsy로 평가되는 값 외 모두 

# 연산자

## 옵셔널 체이닝 연산자

?. 

좌항의 피연산자가 null 혹은 undefined인 경우, undefined를 반환한다. 

ES11(2020+)부터 적용됨 

ex) 객체를 가리키기 기대하는 변수의 값이 null, undefined인 경우 TypeError 방지 용도로 사용이 가능함 

## Null 병합 연산자 (Nullish coalecsing)

좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환함. 그렇지 않으면, 좌항의 피연산자를 반환함

# 함수

## 함수 리터럴

함수는 객체 타입의 값으로, 함수도 함수 리터럴로 생성이 가능함 

특수한 리터럴이면서 객체이므로, 함수만 호출 가능한 프로퍼티가 있음

### 구성요소

**함수 이름**

- 식별자
- 몸체 내에서만 참조할 수 있음
- 생략 가능 (무명 함수 존재)

**매개변수 목록**
 

**함수 몸체** 

- 함수가 호출되었을 때, 일괄적으로 실행될 문들의 하나의 실행 단위로 정의한 블록코드 이다.

## 정의 방법

### 함수 선언식 **(Function Declarations)**

```
함수 선언식 : function add () {}
함수 표현식 : var add = function() {}
```

함수 선언식은'function' 키워드로 시작하고 함수 이름을 명시한다.

표현식이 아닌 문이다. 

함수 선언식은 호이스팅이 된다 (실행컨텍스트 생성 시 평가되기 때문). 함수가 선언되기 전에도 호출할 수 있다.

함수 호이스팅이 발생함

### 함수 표현식 **(Function Expressions)**

지정된 매개변수를 갖는 함수 

표현식인 문이다.  ( 값이 함수 리터럴인 문)

함수 표현식은 변수에 함수를 할당하는 형태로 작성된다.호이스팅되지 않으며(정확히는 변수 호이스팅이 적용됨) 선언되기 전에는 호출할 수 없다.

변수 호이스팅이 발생함

### Function 생성자 함수

생성자를 이용해 생성된 함수. 일반적인 케이스는 아니다. 

### 화살표 함수

함수 표현식으로 정의됨. 기존 함수와 this 바인딩 및 super 바인딩 지원 x, prototype 프로퍼티가 없으며, arguments 객체를 생성하지 않는다. 

## 즉시 호출 함수 (IIFE)

함수 정의와 동시에 즉시 호출되는 함수를 즉시실행함수 라고 한다. 단 한번만 호출되며, 다시 호출할 수 없다. 즉시 실행함수는 반드시 그룹 연산자로 감싸주어야 한다. 

## 콜백함수

함수의 매개변수를 통해, 다른 함수의 내부로 전달되는 함수를 콜백함수라 한다. 

이 때, 익명함수로써 전달하게 되면 고차 함수가 호출될 때 마다 함수 객체가 매번 생성되므로 외부에서 콜백 함수를 정의해주고, 참조를 통해 전달하는 편이 효율적이다.

## 메소드 체이닝이란 무엇인가?

**메소드 체이닝(Method Chaining)** 은 객체의 메서드가 **자기 자신(this) 또는 새로운 객체를 반환**해서, **연속적으로 메서드를 호출할 수 있는 기법**을 말합니다.

## 순수함수와 비순수 함수

### 순수함수

어떠한 외부 상태에 의존하지도 않고, 부수효과 (Side effect)가 없는 함수를 순수함수라 한다.

동일한 인수가 전달되면, 언제나 동일한 값을 반환하는 함수. 인자의 불변성을 유지한다. 

### 비순수 함수

외부 상태에 의존하거나, 부수 효과가 있는 함수를 비순수함수라 한다.

## 함수 호출

- 함수 호출은, 기본적으로 표현식이다.

### 일반 함수 호출

### 매서드 호출

호출한 객체에 함수 객체가 바인딩됨.  따라서, this도 해당 객체를 보게된다.

### apply, call, bind 매서드에 의한 간접 호출

Function.prototype.apply/call/bind 임 

즉, 원시 객체에 정의되어있는 함수들 

apply/call의 차이점은 함수에 인수를 전달하는 방식에서 차이가 있음.

공통점은, 첫 번째 인수로 전달한 특정 객체를 호출 함수의 this에 바인딩함.

apply → arg를 쉼표로 묶어 전달 

call → 배열로 전달 

bind → 함수 호출을 하지 않고, 함수를 ‘반환’함

### 화살표 함수

함수 표현식이다. 객체 리터럴을 반환하는 경우, 소괄호()로 감싸주어야 한다. 

안에 표현식이 들어가있다면,   중괄호로 가싸주어야 한다. 

일급 객체이므로,  MAP이나 Filter, Reduce 와 같은 고차 함수에 인수로 전달이 가능하다. 

### 일반 함수와의 차이

1. 인스턴스 생성할 수 없음
2. 중복된 매개변수 선언 불가
3. 자체 this, arguments, super 바인딩 안가짐. 스코프 체인에 의해 상위 스코프를 참조함  (Lexical this)
- **렉시컬 스코프**
    
    → 함수가 선언된 위치로 **고정** (실행 중에도 변하지 않음).
    
- **this**
    
    → 함수가 어떻게 **호출**되었는지에 따라 **동적으로 결정**.
    
    - 일반 함수 호출 → 전역 객체(`window`) or `undefined` (strict mode)
    - 객체 메서드 호출 → 그 객체
    - `call` / `apply` → 강제로 지정한 객체
    - `new` → 새로 생성한 인스턴스

## 일급객체로써의 함수

함수는 일급 객체의 조건을 만족하므로, 일급 객체로 간주된다.

# Rest 파라미터

***Spread 문법(...)을 사용하여 매개변수를 작성한 형태***를 말한다. 함수의 arguments 정보를 가져올 수 있다. 

# 객체

[03-pdf-slides-big-o-of-arrays-and-objects.pdf](Javascript/03-pdf-slides-big-o-of-arrays-and-objects.pdf)

## 전역객체

- 표준 빌트인 객체 (Object, String ,Number, Function Array)
- 환경에 따른 호스트 객체
- var 키워드로 선언한 전역 변수 → globalThis로 구분해 호출 가능
- 전역 함수

## 일급객체

다음의 조건을 만족하는 객체들을 일급 객체라고 한다. 

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조에 저장할 수 있다.
- 함수의 매개변수에 전달 가능하다.
- 함수의 반환값으로 사용할 수 있다.

# 스코프 (Scope)

식별자가 유효한 범위를 이야기한다. 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 범위가 결정된다. 

또 다른 의미로, 식별자를 검색할 때 사용하는 규칙이라고도 볼 수 있다.

스코프를 누군가 참조하고 있다면, 스코프는 해제되지 않고 생존하게 된다.  

## 전역 스코프

코드의 가장 바깥 영역

## 지역 스코프

함수 몸체 내부 

## 동적스코프

함수를 정의하는 시점에는 함수가 어디서 호출될 지 알 수 없어, 호출되는 시점에 동적으로 상위 스코프를 결정함

## 렉시컬 스코프

함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됨.

클로저의 기능과 연관이 있다.

## 스코프체인 (Scope chain)

스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다. 변수를 참조할 때, 자바스크립트는 스코프 체인 검색을 통해 코드의 스코프에서 시작, 상위 스코프 방향으로 이동하며 선언된 변수를 탐색한다. (식별자를 검색하는 규칙의 관점에서 보는것이 타당함)

## TDZ(Temporal Dead zone)

let, const의 경우, 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 의미함.

`let`, `const`는 **초기화 코드 실행 전까지 접근 불가** → 이 구간이 바로 **TDZ. 이전에는 선언만 등록됨**

# 호이스팅

## Var

변수 선언문 이전에 참조할 수 있다. 다만, 할당문 이전에 변수를 참조하면, 언제나 undefined를 반환한다.

## let

변수 선언문 이전에 참조하면, 참조에러 (Reference error)가 발생함 

선언 단계와 초기화 단계가 분리되기 떄문.

런타임 이전에 선언 단계가 실행되지만, 초기화단계는 런타임 이후에 변수 선언문에 도달했을 때 실행됨.

 

| 구분 | var | let | const |
| --- | --- | --- | --- |
| 스코프 | 함수 스코프 | 블록 스코프 | 블록 스코프 |
| 호이스팅 | 됨(초기값 undefined) | 됨(TDZ 존재) | 됨(TDZ 존재) |
| 재선언 | 가능 | 불가 | 불가 |
| 재할당 | 가능 | 가능 | 불가 |
| 전역 등록 | `window`에 등록 | 등록 안됨 | 등록 안됨 |

# This

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 매소드를 참조할 수 있다. 

## This binding

함수 호출 방식에 따라서 동적으로 호출된다. 렉시컬 스코프와는 다르게, 함수 호출 시점에 결정된다.

### 일반 함수 호출

내부의 this에는 전역 객체가 바인딩됨

# 오류

## Reference Error

`ReferenceError`는 **"식별자가 존재하지 않거나, 아직 초기화되기 전에 접근했을 때"** 발생하는 런타임 에러입니다.

## 1. 선언되지 않은 변수 접근

선언(`var`, `let`, `const`) 자체가 전혀 안 된 식별자에 접근할 때 발생합니다.

```jsx
console.log(a);  // ❌ ReferenceError: a is not define
```

## 2. TDZ(Temporal Dead Zone) 접근

`let` / `const`는 선언되기 전까지 **TDZ**에 있어서 접근하면 `ReferenceError`가 납니다.

```jsx
console.log(b);  // ❌ ReferenceError
let b = 10;
```

# 클로저

## 모듈패턴

## 기타 자료형

### Map

- **Key-Value** 쌍을 저장하는 컬렉션
- `Object`와 달리 **모든 값(객체 포함)을 Key로 사용 가능**

### Set

- **중복을 허용하지 않는 값 집합**
- 값 자체가 key 역할을 함

### WeakMap

- **Key는 반드시 객체만 가능**
- Key 객체가 가비지 컬렉션으로 수거되면 WeakMap에서도 자동 제거됨
- **이터러블(반복) 불가**, 크기 확인 불가

### WeakSet

- **Set과 비슷하지만 객체만 저장 가능**
- 객체가 참조 해제되면 자동으로 제거
- 역시 반복 불가, 크기 확인 불가

# 배열 디스트럭팅

- 배열 디스트럭팅의 대상은 이터러블이여야함
- **배열의 값을 원하는 변수에 개별적으로 할당하는 JavaScript 문법**입니다.

`const fruits = ["사과", "복숭아", "바나나"];`

`// 배열 디스트럭팅을 사용하*여 변수에 할당
const [apple, peach, banana] = fruits;*`

[이벤트 관련](Javascript/%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EA%B4%80%EB%A0%A8%20261cee38e89a80ef88b9cba29cd7861d.md)

[실행 컨텍스트](Javascript/%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%20261cee38e89a80ad8fb1f7f24e96fd6a.md)

[**DOM API**](Javascript/DOM%20API%20261cee38e89a8072b76ed284752abf0e.md)

[비동기 처리](Javascript/%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%B2%98%EB%A6%AC%20262cee38e89a80728fbaf7d1c837191f.md)

[프로토타입](Javascript/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%20268cee38e89a80e0af44dd1fdd71ee30.md)

[이터레이터와 이터러블](Javascript/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80%20%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%20268cee38e89a800d9ac9c2365ac6b71e.md)

[각 객체들의 대표 프로토타입 매서드 ](Javascript/%EA%B0%81%20%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98%20%EB%8C%80%ED%91%9C%20%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%20%EB%A7%A4%EC%84%9C%EB%93%9C%20278cee38e89a80f692ace2c07f616cfb.md)